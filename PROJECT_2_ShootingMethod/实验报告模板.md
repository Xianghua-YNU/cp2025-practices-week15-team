# 项目2：打靶法与scipy.solve_bvp求解边值问题 - 实验报告

**学生姓名：** [邵星宇]
**学号：** [20231050032]
**完成日期：** [2025.6.4]

---

## 1. 实验目的

本实验旨在通过实现和比较两种不同的边值问题求解方法，深入理解边值问题的数值求解原理：

1. **掌握打靶法的基本原理**：理解如何将边值问题转化为初值问题，通过迭代调整初始条件来满足边界条件
2. **学习scipy.solve_bvp的使用**：掌握现代科学计算库中边值问题求解器的使用方法
3. **比较不同方法的特点**：分析两种方法在精度、稳定性、计算效率等方面的差异
4. **提高数值计算编程能力**：通过实际编程实现加深对数值方法的理解

## 2. 方法简述

### 2.1 打靶法 (Shooting Method)

打靶法核心思路实现说明
1. 二阶边值问题转化为一阶ODE系统
核心思路：
将二阶ODE降阶为一阶ODE系统，便于使用标准ODE求解器处理：
def ode_system_shooting(y, t):
    return [y[1], -np.pi*(y[0]+1)/4]
转换原理：
定义状态变量：
y0 = u (原始函数)
y1 = u' (一阶导数)
原始方程 u'' = -π(u+1)/4 转化为：
y0' = y1
y1' = -π(y0+1)/4
2. 初始猜测值设置
核心思路：
合理选择初始斜率值，确保迭代收敛：
# 初始斜率猜测
m1 = -1.0  # 基于物理直觉：函数可能从1开始下降
y0 = [u_left, m1]  # [u(0), u'(0)]
设置依据：
边界条件：u(0) = 1 (已知)
初始斜率：选择负值(-1.0)，因为：
函数在x=0处值为1，需要满足在x=1处回到1，负斜率表示函数可能先下降后回升
3. 优化算法调整初始条件
核心思路：
使用割线法迭代调整初始斜率，直到满足右边界条件：
for iteration in range(max_iterations):
    # 割线法更新斜率
    if abs(u_end_2 - u_end_1) < 1e-12:
        m3 = m2 + 0.1
    else:
        m3 = m2 + (u_right - u_end_2) * (m2 - m1) / (u_end_2 - u_end_1)
    # 求解新斜率对应的ODE
    y0[1] = m3
    sol3 = odeint(ode_system_shooting, y0, x)
    u_end_3 = sol3[-1, 0]
    # 检查收敛
    if abs(u_end_3 - u_right) < tolerance:
        return x, sol3[:, 0]    
    # 更新迭代变量
    m1, m2 = m2, m3
    u_end_1, u_end_2 = u_end_2, u_end_3
优化算法原理：
割线法：基于两点函数值构造线性插值
公式：m_new = m2 + (target - u2) * (m2 - m1)/(u2 - u1)
比二分法更快收敛
迭代过程：
使用当前斜率求解ODE，计算右边界误差，根据误差调整斜率，重复直到满足精度要求
4. 关键参数选择依据
容差(tolerance=1e-6)：
平衡计算精度与效率，足够小以确保工程精度，避免过小导致不必要的迭代，最大迭代次数(max_iterations=10)：割线法通常快速收敛(超线性收敛)，10次迭代足够处理多数情况，防止发散情况下无限循环，离散点数(n_points=100)：足够密度以捕捉函数行为，避免过多点增加计算负担，与scipy.solve_bvp的50点形成对比。
斜率调整机制：
# 防止除零错误
if abs(u_end_1) > 1e-12:
    m2 = m1 * u_right / u_end_1
else:
    m2 = m1 + 1.0
当u_end_1接近零时，采用固定增量调整，否则使用比例缩放

### 2.2 scipy.solve_bvp方法

1. ODE系统函数的定义方式
核心实现：
def ode_system_scipy(x, y):
    return np.vstack((y[1], -np.pi*(y[0]+1)/4))
参数顺序：(x, y) 符合 solve_bvp 要求
x：自变量（位置/时间）
y：状态向量（形状为 (n, m)，n=方程数，m=点数）
返回值格式：使用 np.vstack 返回列向量
第一行：y1' = y2（一阶导数）
第二行：y2' = -π(y1+1)/4（原始方程）
向量化计算：直接使用数组运算处理所有点
2. 边界条件函数的构造
核心实现：
def boundary_conditions_scipy(ya, yb):
    return np.array([ya[0] - 1, yb[0] - 1])
参数含义：
ya：左边界状态向量 [u(0), u'(0)]
yb：右边界状态向量 [u(1), u'(1)]
边界条件表示：
左边界：u(0) = 1 → ya[0] - 1 = 0
右边界：u(1) = 1 → yb[0] - 1 = 0
返回值：残差向量，求解器会驱动其趋近零
3. 初始网格的设置策略
x_init = np.linspace(x_start, x_end, n_points)
y_init = np.zeros((2, x_init.size))
y_init[0] = u_left + (u_right - u_left) * (x_init - x_start) / (x_end - x_start)
y_init[1] = (u_right - u_left) / (x_end - x_start)
空间离散：
均匀分布网格点（linspace），默认点数：50（平衡精度与效率）
初始猜测：
状态变量1 (u)：线性插值边界值
y_init[0] = u_left + (u_right - u_left) * (x_init - x_start)/(x_end - x_start)
状态变量2 (u')：常数斜率
y_init[1] = (u_right - u_left)/(x_end - x_start)
物理意义：假设解在边界间线性变化
4. 参数调优的考虑
求解器调用：
sol = solve_bvp(ode_system_scipy, 
               boundary_conditions_scipy, 
               x_init, y_init, 
               max_nodes=10000)
关键参数调优：
max_nodes=10000
作用：允许网格自适应细化
依据：
确保求解器有足够自由度捕捉非线性行为，防止简单问题中过早达到节点上限
容差控制（隐式）：
使用求解器默认容差（约1e-3），对多数工程问题足够精确，可通过tol参数调整
网格细化：求解器自动在解变化剧烈区域加密网格
后处理时使用更细网格：
x_fine = np.linspace(x_start, x_end, 100)
y_fine = sol.sol(x_fine)[0]
错误处理：
if not sol.success:
    raise RuntimeError(f"scipy.solve_bvp failed: {sol.message}")
检查求解状态。


## 3. 实验结果

### 3.1 数值结果对比

[请填写关键数值结果，建议使用表格形式]

| 方法 | 边界条件满足程度 | 最大误差 | RMS误差 | 计算时间 |
|------|------------------|----------|---------|----------|
| 打靶法 | [填写] | [填写] | [填写] | [填写] |
| scipy.solve_bvp | [填写] | [填写] | [填写] | [填写] |

### 3.2 图表结果
![bvp_solution_comparison](https://github.com/user-attachments/assets/80c20b93-ec53-4ba0-9cf0-88d3980a1d2f)


![Fi](https://github.com/user-attachments/assets/82bd429c-2758-4e3c-96c2-3bd6a270060c)


## 4. 分析与讨论

### 4.1 精度分析

[请分析两种方法的求解精度，包括：]
- 边界条件的满足程度
- 解的光滑性和连续性
- 与理论解（如果已知）的比较
- 网格密度对精度的影响

### 4.2 稳定性分析

[请讨论两种方法的数值稳定性，包括：]
- 对初始猜测值的敏感性
- 参数变化对结果的影响
- 收敛性能的比较
- 可能出现的数值问题及解决方案

### 4.3 计算效率分析

[请比较两种方法的计算效率，包括：]
- 计算时间的对比
- 内存使用情况
- 算法复杂度的理论分析
- 适用场景的讨论

### 4.4 思考题

1. **方法选择**：在什么情况下你会选择打靶法，什么情况下选择scipy.solve_bvp？请结合实验结果说明理由。

   [请回答]

2. **参数优化**：如何选择打靶法中的初始猜测值？如果初始猜测不当会出现什么问题？

   [请回答]

3. **扩展应用**：如果要求解非线性边值问题，两种方法需要如何修改？哪种方法更容易扩展？

   [请回答]

## 5. 结论

[请总结本次实验的主要收获，包括：]
- 对两种边值问题求解方法的理解
- 实验中遇到的主要困难及解决方法
- 数值方法选择的一般性原则
- 对后续学习的启发

## 6. 核心代码片段

### 6.1 打靶法核心实现

```python
# 请粘贴你实现的打靶法核心代码片段
# 包括ODE系统定义、优化过程等关键部分

def solve_bvp_shooting_method(x_span, boundary_conditions, n_points=100):
    # [你的核心实现代码]
    pass
```

### 6.2 scipy.solve_bvp封装实现

```python
# 请粘贴你实现的scipy.solve_bvp封装代码
# 包括ODE系统、边界条件函数等

def solve_bvp_scipy_wrapper(x_span, boundary_conditions, n_points=100):
    # [你的核心实现代码]
    pass
```

### 6.3 方法比较核心代码

```python
# 请粘贴你实现的方法比较和可视化代码片段

def compare_methods_and_plot():
    # [你的核心实现代码]
    pass
```

---

**注意事项：**
1. 请确保所有图表标注使用英文
2. 数值结果保留适当的有效数字
3. 分析讨论要结合具体的实验数据
4. 代码片段应突出核心算法思想
